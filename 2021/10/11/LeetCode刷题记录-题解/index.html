<!DOCTYPE html>
<html lang="en">
    <head>
    <meta charset="utf-8">

    

    <!-- 渲染优化 -->
    <meta name="renderer" content="webkit">
    <meta name="force-rendering" content="webkit">
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="HandheldFriendly" content="True" >
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

    <!--icon-->

    
    
    
        <link rel="icon" type="image/png" sizes="32x32" href="/icons/myico.png">
    
    
    


    <!-- meta -->


<title>LeetCode刷题记录&amp;题解 | 咸鱼养殖场</title>


    <meta name="keywords" content="LeetCode, 算法, C++">




    <!-- OpenGraph -->
 
    <meta name="description" content="不定期更新一些笔者的刷题记录和基于个人理解的题解，不一定又对又快又小，但是肯定能过">
<meta property="og:type" content="article">
<meta property="og:title" content="LeetCode刷题记录&amp;题解">
<meta property="og:url" content="http://example.com/2021/10/11/LeetCode%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95-%E9%A2%98%E8%A7%A3/index.html">
<meta property="og:site_name" content="咸鱼养殖场">
<meta property="og:description" content="不定期更新一些笔者的刷题记录和基于个人理解的题解，不一定又对又快又小，但是肯定能过">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2021-10-11T01:16:43.000Z">
<meta property="article:modified_time" content="2023-03-20T14:53:14.085Z">
<meta property="article:author" content="罐头鱼">
<meta property="article:tag" content="LeetCode">
<meta property="article:tag" content="算法">
<meta property="article:tag" content="C++">
<meta name="twitter:card" content="summary_large_image">


    
<link rel="stylesheet" href="/css/style/main.css">
 

    
    
        <link rel="stylesheet" id="hl-default-theme" href="/css/highlight/default.css" media="none" >
        
            <link rel="stylesheet" id="hl-dark-theme" href="/css/highlight/dark.css" media="none">
        
    

    
    

    
    
<link rel="stylesheet" href="/css/style/dark.css">

    
<script src="/js/darkmode.js"></script>



     

    <!-- custom head -->

<meta name="generator" content="Hexo 5.4.0"></head>

    <body>
        <div id="app">
            <header class="header">
    <div class="header__left">
        <a href="/" class="button">
            <span class="logo__text">咸鱼养殖场</span>
        </a>
    </div>
    <div class="header__right">
        
            <div class="navbar__menus">
                
                    <a href="/" class="navbar-menu button">首页</a>
                
                    <a href="/tags/" class="navbar-menu button">标签</a>
                
                    <a href="/categories/" class="navbar-menu button">分类</a>
                
                    <a href="/archives/" class="navbar-menu button">时间线</a>
                
                    <a href="/friends/" class="navbar-menu button">大腿们</a>
                
            </div>
        
        
        

        
        
    <a href="javaScript:void(0);" id="btn-toggle-dark">
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path></svg>
    </a>


        
            <a class="dropdown-icon button" id="btn-dropdown" tabindex="0"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 20 20" width='24' height='24' fill="none" stroke="currentColor" stroke-width="0.7" stroke-linecap="round" stroke-linejoin="round"><path fill="currentColor" d="M3.314,4.8h13.372c0.41,0,0.743-0.333,0.743-0.743c0-0.41-0.333-0.743-0.743-0.743H3.314c-0.41,0-0.743,0.333-0.743,0.743C2.571,4.467,2.904,4.8,3.314,4.8z M16.686,15.2H3.314c-0.41,0-0.743,0.333-0.743,0.743s0.333,0.743,0.743,0.743h13.372c0.41,0,0.743-0.333,0.743-0.743S17.096,15.2,16.686,15.2z M16.686,9.257H3.314c-0.41,0-0.743,0.333-0.743,0.743s0.333,0.743,0.743,0.743h13.372c0.41,0,0.743-0.333,0.743-0.743S17.096,9.257,16.686,9.257z"></path></svg></a>
            <div class="dropdown-menus" id="dropdown-menus">
                
                    <a href="/" class="dropdown-menu button">首页</a>
                
                    <a href="/tags/" class="dropdown-menu button">标签</a>
                
                    <a href="/categories/" class="dropdown-menu button">分类</a>
                
                    <a href="/archives/" class="dropdown-menu button">时间线</a>
                
                    <a href="/friends/" class="dropdown-menu button">大腿们</a>
                
            </div>
        
    </div>
</header>


            <main class="main">
    

<div class="post-title">
    <h1 class="post-title__text">
        LeetCode刷题记录&amp;题解
    </h1>
    <div class="post-title__meta">
        <a href="/archives/2021/10/" class="post-meta__date button">2021-10-11</a>
        
 
        
    
    


 

 
    </div>
</div>


    <aside class="post-side">
        <div class="post-side__toc">
            <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E6%8B%9F"><span class="toc-text">模拟</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="toc-text">1.两数之和</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%88"><span class="toc-text">栈</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97-%E5%89%91%E6%8C%87offer-09"><span class="toc-text">1.用两个栈实现队列(剑指offer 09)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88-%E5%89%91%E6%8C%87offer-30"><span class="toc-text">2.包含min函数的栈(剑指offer 30)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8-%E5%89%91%E6%8C%87offer-06"><span class="toc-text">3.从尾到头打印链表(剑指offer 06)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8-%E5%89%91%E6%8C%87offer-24"><span class="toc-text">4.反转链表(剑指offer 24)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8"><span class="toc-text">链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC-%E5%89%91%E6%8C%87offer-05"><span class="toc-text">1.替换空格(剑指offer 05)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2-%E5%89%91%E6%8C%87offer-58"><span class="toc-text">2.左旋转字符串(剑指offer 58)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3"><span class="toc-text">滑动窗口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD1%E7%9A%84%E4%B8%AA%E6%95%B0-III-1008"><span class="toc-text">1.最大连续1的个数 III(1008)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-text">动态规划</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C-64"><span class="toc-text">1.最小路径和(64)</span></a></li></ol></li></ol>
        </div>
    </aside>
    <a class="btn-toc button" id="btn-toc" tabindex="0">
        <svg viewBox="0 0 1024 1024" width="32" height="32" xmlns="http://www.w3.org/2000/svg">
            <path d="M128 256h64V192H128zM320 256h576V192H320zM128 544h64v-64H128zM320 544h576v-64H320zM128 832h64v-64H128zM320 832h576v-64H320z" fill="currentColor"></path>
        </svg>
    </a>
    <div class="toc-menus" id="toc-menus">
        <div class="toc-title">Article Directory</div>
        <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E6%8B%9F"><span class="toc-text">模拟</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%B8%A4%E6%95%B0%E4%B9%8B%E5%92%8C"><span class="toc-text">1.两数之和</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%88"><span class="toc-text">栈</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97-%E5%89%91%E6%8C%87offer-09"><span class="toc-text">1.用两个栈实现队列(剑指offer 09)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88-%E5%89%91%E6%8C%87offer-30"><span class="toc-text">2.包含min函数的栈(剑指offer 30)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8-%E5%89%91%E6%8C%87offer-06"><span class="toc-text">3.从尾到头打印链表(剑指offer 06)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8-%E5%89%91%E6%8C%87offer-24"><span class="toc-text">4.反转链表(剑指offer 24)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8"><span class="toc-text">链表</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-text">字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC-%E5%89%91%E6%8C%87offer-05"><span class="toc-text">1.替换空格(剑指offer 05)</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2-%E5%89%91%E6%8C%87offer-58"><span class="toc-text">2.左旋转字符串(剑指offer 58)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3"><span class="toc-text">滑动窗口</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%9C%80%E5%A4%A7%E8%BF%9E%E7%BB%AD1%E7%9A%84%E4%B8%AA%E6%95%B0-III-1008"><span class="toc-text">1.最大连续1的个数 III(1008)</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-text">动态规划</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E6%9C%80%E5%B0%8F%E8%B7%AF%E5%BE%84%E5%92%8C-64"><span class="toc-text">1.最小路径和(64)</span></a></li></ol></li></ol>
    </div>


<article class="post post__with-toc content-card">
    <div class="post__header"></div>
    <div class="post__content">
        <p>不定期更新一些笔者的刷题记录和基于个人理解的题解，不一定又对又快又小，但是肯定能过</p>
<span id="more"></span>

<h1 id="LeetCode刷题记录-amp-题解"><a href="#LeetCode刷题记录-amp-题解" class="headerlink" title="LeetCode刷题记录&amp;题解"></a>LeetCode刷题记录&amp;题解</h1><p>大概2020年的时候笔者曾经刷过一阵子LeetCode，不过写了不到100道题就草草收场了。现在再看曾经做过的题，好家伙一道都没见过，一道都不会。既然如此那就从零开始再来一遍吧，争取能把学到的东西好好记录下来，不要再忘第二次。<br>目前做题的语言为C++，纯粹是因为这学期选了C++的课可以顺便拿来练手<del>(听说作业里也有OJ)</del>。<br>那么废话就说到这里，开整！</p>
<h2 id="模拟"><a href="#模拟" class="headerlink" title="模拟"></a>模拟</h2><h3 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1.两数之和"></a>1.两数之和</h3><p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。</p>
<p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p>
<p>你可以按任意顺序返回答案。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：nums = [2,7,11,15], target = 9</span><br><span class="line">输出：[0,1]</span><br><span class="line">解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：nums = [3,2,4], target = 6</span><br><span class="line">输出：[1,2]</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line"></span><br><span class="line">输入：nums = [3,3], target = 6</span><br><span class="line">输出：[0,1]</span><br></pre></td></tr></table></figure>
<p>没啥好说的，干就完了。<br><strong>思路1：两层for暴力破解</strong><br>i从<code>0~length</code>,j从<code>i+1~length</code>搜索，<code>num[i]+num[j]=target</code>输出即可</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n=nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>; j &lt; n; j++)</span><br><span class="line">                <span class="keyword">if</span>((nums[i]+nums[j])==target)</span><br><span class="line">                    <span class="keyword">return</span> &#123;i,j&#125;;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>思路2：哈希表查找</strong><br>创建unordered map，从中直接查找输出即可</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; hashtable;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)</span><br><span class="line">            &#123;</span><br><span class="line">            hashtable[nums[i]] = i;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> it = hashtable.<span class="built_in">find</span>(target - nums[i]);</span><br><span class="line">            <span class="keyword">if</span> ((it != hashtable.<span class="built_in">end</span>())&amp;&amp;(it-&gt;second!=i))&#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;i,it-&gt;second&#125;;&#125;</span><br><span class="line">                &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><h3 id="1-用两个栈实现队列-剑指offer-09"><a href="#1-用两个栈实现队列-剑指offer-09" class="headerlink" title="1.用两个栈实现队列(剑指offer 09)"></a>1.用两个栈实现队列(剑指offer 09)</h3><p>用两个栈实现一个队列。队列的声明如下，请实现它的两个函数 appendTail 和 deleteHead ，分别完成在队列尾部插入整数和在队列头部删除整数的功能。(若队列中没有元素，deleteHead 操作返回 -1 )</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">[&quot;CQueue&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;]</span><br><span class="line">[[],[3],[],[]]</span><br><span class="line">输出：[null,null,3,-1]</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：</span><br><span class="line">[&quot;CQueue&quot;,&quot;deleteHead&quot;,&quot;appendTail&quot;,&quot;appendTail&quot;,&quot;deleteHead&quot;,&quot;deleteHead&quot;]</span><br><span class="line">[[],[],[5],[2],[],[]]</span><br><span class="line">输出：[null,-1,null,null,5,2]</span><br></pre></td></tr></table></figure>
<p>首先，明确栈和队列的特征和题面要求：</p>
<p><strong>栈：  先入后出，先进入的元素会放到栈底，之后的元素会放到先入元素的上方，称为栈顶，出栈时从栈顶开始依次出栈</strong><br><strong>队列：先入先出，先进入的元素会放到队列头部，之后的元素会放到先入元素的上方，称为队尾，出队列时从队列头部开始依次出队</strong></p>
<p>题目提供了两个栈，那么最直观的思路就是一个栈模拟队头一个栈模拟队尾，暂定模拟队尾的栈为栈1，模拟队头的栈为栈2<br>在队列尾部插入整数，和在栈顶放入元素是一样的，直接用栈1的<code>push()</code>函数即可实现<br>随着在栈1中不断加入元素，作为队列头部的元素会被放到栈1底部，那么当需要在队列头部删除数据时，需要把该元素从栈1的底部取出来<br>结合栈2模拟队头，那么问题变成把栈1的栈底元素变成栈2的栈顶元素，思路就简单了<br>使用栈1的<code>pop()</code>函数可以把栈1的栈顶元素取出来，再结合栈2的<code>push()</code>函数，可以把栈1的栈顶元素放到栈2的栈底，反复执行该操作直到栈1清空，栈1的栈底元素就变成了栈2的栈顶元素，之后再调用栈2的<code>pop()</code>函数即可实现删除队头元素的功能</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CQueue</span> &#123;</span></span><br><span class="line">    stack&lt;<span class="keyword">int</span>&gt; s1,s2;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">CQueue</span>() &#123;</span><br><span class="line">        <span class="keyword">while</span>(!s1.<span class="built_in">empty</span>())</span><br><span class="line">            s1.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">while</span>(!s2.<span class="built_in">empty</span>())</span><br><span class="line">            s2.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;<span class="comment">//初始化，把S1、S2的内容全部清空</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">appendTail</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">        s1.<span class="built_in">push</span>(value);</span><br><span class="line">    &#125;<span class="comment">//在队列的尾部插入元素</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">deleteHead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!s2.<span class="built_in">empty</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = s2.<span class="built_in">top</span>();</span><br><span class="line">                s2.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">return</span> temp;</span><br><span class="line">            &#125;<span class="comment">//如果当前S2内仍有内容，则此时的S2栈顶即为队列尾部元素，直接删除即可</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (!s1.<span class="built_in">empty</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                s2.<span class="built_in">push</span>(s1.<span class="built_in">top</span>());</span><br><span class="line">                s1.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;<span class="comment">//如果S2为空，S1不为空，则把S1栈内元素全部移至S2</span></span><br><span class="line">            <span class="keyword">if</span>(!s2.<span class="built_in">empty</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> temp = s2.<span class="built_in">top</span>();</span><br><span class="line">                s2.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">return</span> temp;</span><br><span class="line">            &#125;<span class="comment">//转移完成后，若S2不为空，则把S2栈顶元素删除</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//若转移后S2依然为空(即S1、S2均为空，队列为空白队列)，输出-1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2-包含min函数的栈-剑指offer-30"><a href="#2-包含min函数的栈-剑指offer-30" class="headerlink" title="2.包含min函数的栈(剑指offer 30)"></a>2.包含min函数的栈(剑指offer 30)</h3><p>定义栈的数据结构，请在该类型中实现一个能够得到栈的最小元素的 min 函数在该栈中，调用 min、push 及 pop 的时间复杂度都是 O(1)。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">示例 ：</span><br><span class="line"></span><br><span class="line">MinStack minStack = new MinStack();</span><br><span class="line">minStack.push(-2);</span><br><span class="line">minStack.push(0);</span><br><span class="line">minStack.push(-3);</span><br><span class="line">minStack.min();   --&gt; 返回 -3.</span><br><span class="line">minStack.pop();</span><br><span class="line">minStack.top();      --&gt; 返回 0.</span><br><span class="line">minStack.min();   --&gt; 返回 -2.</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>做过上一道题的话，会考虑用两个栈解决问题。那么一个栈完成题上的基本功能，另一个很明显完成输出最小值的工作即可。那么思路就很清晰了：<br><strong>每一次向栈1存元素时，把当前的最小值同时存入栈2</strong><br>那么栈2的栈顶元素就总是当前状态下的最小值。代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> &#123;</span></span><br><span class="line">    stack&lt;<span class="keyword">int</span>&gt; s,mins;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MinStack</span>() &#123;</span><br><span class="line">        mins.<span class="built_in">push</span>(INT_MAX); <span class="comment">//向栈2存入INT_MAX，保证第一次数据必会进入栈2</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        s.<span class="built_in">push</span>(x);</span><br><span class="line">        <span class="keyword">if</span>(x&lt;=mins.<span class="built_in">top</span>()) <span class="comment">//比较新元素和当前的最小值，若新元素更小则更新栈2</span></span><br><span class="line">            mins.<span class="built_in">push</span>(x);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            mins.<span class="built_in">push</span>(mins.<span class="built_in">top</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;<span class="comment">//使用pop时要同时更新栈2</span></span><br><span class="line">        s.<span class="built_in">pop</span>();</span><br><span class="line">        mins.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mins.<span class="built_in">top</span>(); <span class="comment">//提取最小值</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="3-从尾到头打印链表-剑指offer-06"><a href="#3-从尾到头打印链表-剑指offer-06" class="headerlink" title="3.从尾到头打印链表(剑指offer 06)"></a>3.从尾到头打印链表(剑指offer 06)</h3><p>输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例：</span><br><span class="line"></span><br><span class="line">输入：head = [1,3,2]</span><br><span class="line">输出：[2,3,1]</span><br></pre></td></tr></table></figure>

<p>链表的格式及操作：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line">      <span class="keyword">int</span> val;</span><br><span class="line">      ListNode *next;</span><br><span class="line"></span><br><span class="line">      <span class="built_in">ListNode</span>(<span class="keyword">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure>

<p>链表从尾到头打印，很容易想到使用栈来解决。把链表元素依次存入栈里，然后再把栈里的元素依次输出即可。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line">    stack&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">reversePrint</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">NULL</span>) <span class="keyword">return</span> ans;</span><br><span class="line">        <span class="keyword">while</span>(head!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            s.<span class="built_in">push</span>(head-&gt;val);</span><br><span class="line">            head=head-&gt;next;</span><br><span class="line">            &#125;<span class="comment">//把链表的元素值存到栈里</span></span><br><span class="line">        <span class="keyword">while</span>(!s.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(s.<span class="built_in">top</span>());</span><br><span class="line">            s.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;<span class="comment">//把栈的值输出即可</span></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="4-反转链表-剑指offer-24"><a href="#4-反转链表-剑指offer-24" class="headerlink" title="4.反转链表(剑指offer 24)"></a>4.反转链表(剑指offer 24)</h3><p>定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例:</span><br><span class="line"></span><br><span class="line">输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><br><span class="line">输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</span><br></pre></td></tr></table></figure>

<p>关键词：<strong>反转</strong> 显然可以用栈来解决。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head==<span class="literal">NULL</span>) <span class="keyword">return</span> head;</span><br><span class="line">        stack&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        ListNode* cur=head;</span><br><span class="line">        ListNode* ans=head;</span><br><span class="line">        <span class="keyword">while</span>(cur!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            s.<span class="built_in">push</span>(cur-&gt;val);</span><br><span class="line">            cur=cur-&gt;next;</span><br><span class="line">        &#125;<span class="comment">//把原链表元素存入栈里</span></span><br><span class="line">        cur=head;</span><br><span class="line">        <span class="keyword">while</span>(!s.<span class="built_in">empty</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            cur-&gt;val=s.<span class="built_in">top</span>();</span><br><span class="line">            s.<span class="built_in">pop</span>();</span><br><span class="line">            cur=cur-&gt;next;</span><br><span class="line">        &#125;<span class="comment">//再把栈内的元素从链表的头节点开始依次存回链表</span></span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><h3 id="1-替换空格-剑指offer-05"><a href="#1-替换空格-剑指offer-05" class="headerlink" title="1.替换空格(剑指offer 05)"></a>1.替换空格(剑指offer 05)</h3><p>请实现一个函数，把字符串 s 中的每个空格替换成”%20”。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">示例：</span><br><span class="line"></span><br><span class="line">输入：s = &quot;We are happy.&quot;</span><br><span class="line">输出：&quot;We%20are%20happy.&quot;</span><br></pre></td></tr></table></figure>

<p>字符串基础，新建一个字符串，遍历一编输入字符串，遇到空格就加上<code>%20</code>,其他的加上原字符串的内容即可。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">replaceSpace</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">size</span>()==<span class="number">0</span>) <span class="keyword">return</span> s;</span><br><span class="line">        string ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[i]==<span class="string">&#x27; &#x27;</span>) ans=ans+<span class="string">&quot;%20&quot;</span>;</span><br><span class="line">            <span class="keyword">else</span> ans=ans+s[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2-左旋转字符串-剑指offer-58"><a href="#2-左旋转字符串-剑指offer-58" class="headerlink" title="2.左旋转字符串(剑指offer 58)"></a>2.左旋转字符串(剑指offer 58)</h3><p>字符串的左旋转操作是把字符串前面的若干个字符转移到字符串的尾部。请定义一个函数实现字符串左旋转操作的功能。比如，输入字符串”abcdefg”和数字2，该函数将返回左旋转两位得到的结果”cdefgab”。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入: s = &quot;abcdefg&quot;, k = 2</span><br><span class="line">输出: &quot;cdefgab&quot;</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入: s = &quot;lrloseumgh&quot;, k = 6</span><br><span class="line">输出: &quot;umghlrlose&quot;</span><br></pre></td></tr></table></figure>

<p>本题为字符串拼接，把字符串的前n个字符拼接到字符串的尾部。建立两个子字符串分别存储原字符串的左边和右边，然后反过来拼接即可。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseLeftWords</span><span class="params">(string s, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        string l,r;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i &lt; n) r+=s[i]; <span class="comment">//前n个字符存储到字符串r中</span></span><br><span class="line">            <span class="keyword">else</span>    l+=s[i];   <span class="comment">//其他的字符存储到字符串l中</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> l+r;            <span class="comment">//返回l+r</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h2><h3 id="1-最大连续1的个数-III-1008"><a href="#1-最大连续1的个数-III-1008" class="headerlink" title="1.最大连续1的个数 III(1008)"></a>1.最大连续1的个数 III(1008)</h3><p>给定一个二进制数组 nums 和一个整数 k，如果可以翻转最多 k 个 0 ，则返回 数组中连续 1 的最大个数 。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,1,1,0,0,0,1,1,1,1,0], K = 2</span><br><span class="line">输出：6</span><br><span class="line">解释：[1,1,1,0,0,1,1,1,1,1,1]</span><br><span class="line"></span><br><span class="line">输入：nums = [0,0,1,1,0,0,1,1,1,0,1,1,0,0,0,1,1,1,1], K = 3</span><br><span class="line">输出：10</span><br><span class="line">解释：[0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,1,1,1,1]</span><br></pre></td></tr></table></figure>

<p>连续个1的最大个数，也就是数组里面全是1的子数组的最大长度，也就是区间的长度。因为存在k个0可以被反转成1，所以这个区间里可以包括的内容是：<br>1.连续的1<br>2.随意穿插的k个0<br>那么根据这个思路，构建滑动窗口解题即可：</p>
<p>窗口左边界：left<br>窗口右边界：right<br>右边界增加条件：自动增加<br>需更新的参数：一个计数器，用于记录窗口中0的数量<br>左边界增加条件：窗口中0的数量大于k时，增加左边界直到窗口内0的数量小于等于k</p>
<p>代码(参考作者——负雪明烛的题解，<a target="_blank" rel="noopener" href="https://leetcode.cn/problems/max-consecutive-ones-iii/solutions/609055/fen-xiang-hua-dong-chuang-kou-mo-ban-mia-f76z/">链接</a> )：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestOnes</span><span class="params">(vector&lt; <span class="keyword">int</span> &gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> zero = <span class="number">0</span>; <span class="comment">//计数器，记录0的数量</span></span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">0</span>;<span class="comment">//右边界</span></span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;<span class="comment">//左边界</span></span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(right = <span class="number">0</span>; right &lt; nums.<span class="built_in">size</span>(); right++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[right]==<span class="number">0</span>) <span class="comment">//新的0加入窗口</span></span><br><span class="line">                zero++;</span><br><span class="line">            <span class="keyword">while</span>(zero &gt; k) <span class="comment">//0的数量超过k</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[left]==<span class="number">0</span>) <span class="comment">//左移left，直到多余的0离开窗口</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        left++;</span><br><span class="line">                        zero--;</span><br><span class="line">                    &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(ans &lt; (right-left+<span class="number">1</span>))   ans = right-left+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>


<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><h3 id="1-最小路径和-64"><a href="#1-最小路径和-64" class="headerlink" title="1.最小路径和(64)"></a>1.最小路径和(64)</h3><p>给定一个包含非负整数的 m x n 网格 grid ，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</p>
<p>说明：每次只能向下或者向右移动一步。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">![](minpath.png)</span><br><span class="line">输入：grid = [[1,3,1],[1,5,1],[4,2,1]]</span><br><span class="line">输出：7</span><br><span class="line">解释：因为路径 1→3→1→1→1 的总和最小。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：grid = [[1,2,3],[4,5,6]]</span><br><span class="line">输出：12</span><br></pre></td></tr></table></figure>

<p>因为每次只能<strong>向下</strong>或<strong>向右</strong>移动，所以当到达某一点(i,j)时，它必然来自于它的<strong>上方(i-1,j)<strong>或</strong>左方(i,j-1)</strong>,因此想要让到达这一点的数字总和最小，只要取它左方和上方里较小的那一个，加上自己的值就可以了。因此，这道题可以使用动态规划的思路来解，状态转移方程如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">dp</span>(i,j)=max[<span class="built_in">grid</span>(i,j<span class="number">-1</span>),<span class="built_in">grid</span>(i,j<span class="number">-1</span>)]+<span class="built_in">grid</span>(i,j)</span><br></pre></td></tr></table></figure>

<p>代码如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(vector&lt; vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = grid.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> dp[m][n];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; m; i++)</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j&lt; n; j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">0</span> &amp;&amp; j==<span class="number">0</span>) dp[i][j] = grid[i][j];<span class="comment">//起始点</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(i==<span class="number">0</span>) dp[i][j] = dp[i][j<span class="number">-1</span>]+grid[i][j]; <span class="comment">//网格的最上方一行</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j==<span class="number">0</span>) dp[i][j] = dp[i<span class="number">-1</span>][j]+grid[i][j]; <span class="comment">//网格的最左方一列</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                dp[i][j] = <span class="built_in">min</span>(dp[i][j<span class="number">-1</span>],dp[i<span class="number">-1</span>][j])+grid[i][j]; <span class="comment">//状态转移方程</span></span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m<span class="number">-1</span>][n<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
    </div>
     
    <div class="post-footer__meta"><p>updated at 2023-03-20</p></div> 
    <div class="post-entry__tags"><a href="/tags/LeetCode/" class="post-tags__link button"># LeetCode</a><a href="/tags/%E7%AE%97%E6%B3%95/" class="post-tags__link button"># 算法</a><a href="/tags/C/" class="post-tags__link button"># C++</a></div> 
</article>


    <div class="nav">
        <div class="nav__prev">
            
                <a href="/2021/10/23/Matlab%E4%B8%8E%E8%B4%9D%E5%A1%9E%E5%B0%94%E5%87%BD%E6%95%B0%E2%80%94%E2%80%94%E8%AE%B0%E4%B8%80%E6%AC%A1%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3/" class="nav__link">
                    <div>
                        <svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" width="24" height="24"><path d="M589.088 790.624L310.464 512l278.624-278.624 45.248 45.248L400.96 512l233.376 233.376z" fill="#808080"></path></svg>
                    </div>
                    <div>
                        <div class="nav__label">
                            Previous Post
                        </div>
                        <div class="nav__title">
                            Matlab与贝塞尔函数——记一次问题解决
                        </div>
                    </div>
                </a>
            
        </div>
        <div class="nav__next">
            
                <a href="/2021/09/10/%E5%85%B3%E4%BA%8E%E6%88%91%E6%98%AF%E6%80%8E%E4%B9%88%E5%87%BA%E7%94%9F%E7%9A%84-%E5%BB%BA%E7%AB%99%E6%B5%81%E7%A8%8B/" class="nav__link">
                    <div>
                        <div class="nav__label">
                            Next Post
                        </div>
                        <div class="nav__title">
                            关于我是怎么出生的(建站流程)
                        </div>
                    </div>
                    <div>
                        <svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" width="24" height="24"><path d="M434.944 790.624l-45.248-45.248L623.04 512l-233.376-233.376 45.248-45.248L713.568 512z" fill="#808080"></path></svg>
                    </div>
                </a>
            
        </div>
    </div>





</main>

            <footer class="footer">
     
    <a href="#" class="button" id="b2t" aria-label="Back to Top" title="Back to Top">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1024 1024" width="32" height="32">
            <path d="M233.376 722.752L278.624 768 512 534.624 745.376 768l45.248-45.248L512 444.128zM192 352h640V288H192z" fill="currentColor"></path>
        </svg>
    </a>

    


    
     
 

 
    
        
        <p class="footer-copyright">
            Copyright © 2023 <a href="/">咸鱼养殖场</a>
        </p>
    
    
    <p>Powered by <a href="https://hexo.io" target="_blank">Hexo</a> | Theme - <a href="https://github.com/ChrAlpha/hexo-theme-cards" target="_blank">Cards</a></p>
</footer>

        </div>
         

 

 

 

 



 



 


    
 

 

 

 

 

 




    </body>
</html>
